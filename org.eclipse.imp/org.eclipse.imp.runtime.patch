Index: org.eclipse.imp.runtime/src/org/eclipse/imp/language/LanguageRegistry.java
===================================================================
--- org.eclipse.imp.runtime/src/org/eclipse/imp/language/LanguageRegistry.java	(revision 22255)
+++ org.eclipse.imp.runtime/src/org/eclipse/imp/language/LanguageRegistry.java	(working copy)
@@ -21,6 +21,8 @@
 import java.util.List;
 import java.util.Map;
 
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.ResourcesPlugin;
 import org.eclipse.core.runtime.IConfigurationElement;
 import org.eclipse.core.runtime.IExtensionPoint;
 import org.eclipse.core.runtime.IPath;
@@ -134,7 +136,7 @@
 	public static Language findLanguage(IEditorInput editorInput, IDocumentProvider docProvider) {
 		if (!sIsFullyInitialized)
 			initializeRegistryAsNeeded();
-		IPath path= EditorInputUtils.getPath(editorInput);
+		IPath path= EditorInputUtils.getFile(editorInput).getFullPath(); // LK
 
 		return findLanguage(path, docProvider.getDocument(editorInput));
 	}
@@ -164,7 +166,9 @@
 		            LanguageValidator validator = lang.getValidator();
 
 		            if (validator != null && docContents != null) {
-		                if (validator.validate(docContents)) {
+		            	// LK: needed for MetaFileLanguageValidator
+		            	IFile file = ResourcesPlugin.getWorkspace().getRoot().getFile(path);
+		            	if (validator.validate(file) ||validator.validate(docContents)) {
 		                    return lang;
 		                }
 		            } else {
@@ -383,7 +387,10 @@
         for (String ext : extensions) {
 	        IFileEditorMapping mapping= findMappingFor(ext, mappings);
 
-	        if (mapping == null || mapping.getDefaultEditor().getId().equals(sUniversalEditor.getId())) {
+	        if (mapping == null
+	        		|| (!(mapping instanceof IMPFileEditorMapping) // LK: mapping may already be a IMPFileEditorMapping 
+	        			 && (mapping.getDefaultEditor() == null
+	        		         || mapping.getDefaultEditor().getId().equals(sUniversalEditor.getId())))) {
 	            // Replace the file editor mapping even if it already pointed to the universal editor,
 	            // since the persisted association turns into a FileEditorMapping when re-read, thus
 	            // losing the icon (which FileEditorMapping gets from the IEditorDescriptor).
Index: org.eclipse.imp.runtime/src/org/eclipse/imp/services/base/TreeModelBuilderBase.java
===================================================================
--- org.eclipse.imp.runtime/src/org/eclipse/imp/services/base/TreeModelBuilderBase.java	(revision 22255)
+++ org.eclipse.imp.runtime/src/org/eclipse/imp/services/base/TreeModelBuilderBase.java	(working copy)
@@ -23,7 +23,8 @@
 
     private Stack<ModelTreeNode> fItemStack= new Stack<ModelTreeNode>();
 
-    public final ModelTreeNode buildTree(Object rootASTNode) {
+    // LK: public interface shouldn't be final
+    public ModelTreeNode buildTree(Object rootASTNode) {
         fItemStack.push(fModelRoot= createTopItem(new ModelTreeNode(rootASTNode)));
         try {
             visitTree(rootASTNode);
Index: org.eclipse.imp.runtime/src/org/eclipse/imp/editor/ServiceControllerManager.java
===================================================================
--- org.eclipse.imp.runtime/src/org/eclipse/imp/editor/ServiceControllerManager.java	(revision 22255)
+++ org.eclipse.imp.runtime/src/org/eclipse/imp/editor/ServiceControllerManager.java	(working copy)
@@ -48,6 +48,11 @@
         if (fLanguageServiceManager.getHyperLinkDetector() != null)
             fHyperLinkController= new SourceHyperlinkController(fLanguageServiceManager.getHyperLinkDetector(), fTextEditor);
     }
+    
+    public ServiceControllerManager() { // LK: TODO: REMOVE ME
+    	fTextEditor = null;
+    
+    }
 
     public void initialize() {
         IRegionSelectionService regionSelector= (IRegionSelectionService) fTextEditor.getAdapter(IRegionSelectionService.class);
Index: org.eclipse.imp.runtime/src/org/eclipse/imp/editor/ParserScheduler.java
===================================================================
--- org.eclipse.imp.runtime/src/org/eclipse/imp/editor/ParserScheduler.java	(revision 22255)
+++ org.eclipse.imp.runtime/src/org/eclipse/imp/editor/ParserScheduler.java	(working copy)
@@ -29,6 +29,7 @@
 import org.eclipse.jface.text.IDocument;
 import org.eclipse.ui.IEditorInput;
 import org.eclipse.ui.IEditorPart;
+import org.eclipse.ui.texteditor.AbstractTextEditor;
 import org.eclipse.ui.texteditor.IDocumentProvider;
 
 /**
@@ -64,7 +65,7 @@
     }
 
     public IStatus run(IProgressMonitor monitor) {
-        if (fParseController == null || fDocumentProvider == null) {
+        if (fParseController == null || ((AbstractTextEditor) fEditorPart).getDocumentProvider() == null) { // LK: test if document provider is null to find out if editor was closed
             /* Editor was closed, or no parse controller */
             return Status.OK_STATUS;
         }
@@ -82,8 +83,9 @@
             // Just make sure the document contents gets parsed once (and only once).
             fMsgHandler.clearMessages();
             fParseController.parse(document.get(), monitor);
-            if (!monitor.isCanceled())
+            if (!monitor.isCanceled()) {
                 notifyModelListeners(monitor);
+            }
         } catch (Exception e) {
             ErrorHandler.reportError("Error running parser for language " + fParseController.getLanguage().getName() + " and input " + editorInput.getName() + ":", e);
             // RMF 8/2/2006 - Notify the AST listeners even on an exception - the compiler front end
Index: org.eclipse.imp.runtime/src/org/eclipse/imp/editor/internal/PresentationController.java
===================================================================
--- org.eclipse.imp.runtime/src/org/eclipse/imp/editor/internal/PresentationController.java	(revision 22255)
+++ org.eclipse.imp.runtime/src/org/eclipse/imp/editor/internal/PresentationController.java	(working copy)
@@ -13,6 +13,7 @@
 
 import java.io.PrintStream;
 import java.util.ArrayList;
+import java.util.EmptyStackException;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Stack;
@@ -109,6 +110,9 @@
         IRegion bigRegion= fColorer.calculateDamageExtent(region, fParseCtlr);
 
         if (bigRegion != null) {
+        	// LK: (no changes, just a comment)
+        	// No synchronized statement here avoids a deadlock in the colorer implementation,
+        	// which might need main thread access to create new SWT Color Objects 
             fWorkItems.push(bigRegion);
         }
     }
@@ -118,13 +122,18 @@
 //            if (fWorkItems.size() == 0) {
 //                ConsoleUtil.findConsoleStream(PresentationController.CONSOLE_NAME).println("PresentationController.update() called, but no damage in the work queue?");
 //            }
-            synchronized (fWorkItems) {
-                for(int n= fWorkItems.size() - 1; !monitor.isCanceled() && n >= 0; n--) {
-                    Region damage= (Region) fWorkItems.get(n);
-                    changeTextPresentationForRegion(controller, monitor, damage);
-                }
-                if (!monitor.isCanceled())
-                    fWorkItems.removeAllElements();
+        	// LK: locking using fWorkItems as syncroot can result in deadlocks
+            synchronized (this) {
+            	try {
+	                while (!monitor.isCanceled() && !fWorkItems.isEmpty()) {
+	                    Region damage = (Region) fWorkItems.pop();
+	                    changeTextPresentationForRegion(controller, monitor, damage);
+	                }
+	                // if (!monitor.isCanceled())
+	                //    fWorkItems.removeAllElements();
+            	} catch (EmptyStackException e) {
+            		// Ignore
+            	}
             }
         }
     }
@@ -157,7 +166,7 @@
             int offset= locator.getStartOffset(token);
             int end= locator.getEndOffset(token);
 
-            if (offset <= prevEnd && end >= prevOffset) {
+            if (offset <= prevEnd /*&& end >= prevOffset*/) { // LK: Avoid illegal styleRange
                 continue;
             }
             changeTokenPresentation(parseController, presentation, token, locator);
@@ -176,7 +185,7 @@
         
        // SMS 21 Jun 2007:  negative (possibly 0) length style ranges seem to cause problems;
         // but if you have one it should lead to an IllegalArgumentException in changeTextPresentation(..)
-        if (styleRange.length <= 0 || styleRange.start + styleRange.length > this.fSourceViewer.getDocument().getLength()) {
+        if (styleRange.length <= 0 ||  this.fSourceViewer.getDocument() == null || styleRange.start + styleRange.length > this.fSourceViewer.getDocument().getLength()) {
         } else {
             presentation.addStyleRange(styleRange);
         }
@@ -190,6 +199,7 @@
             	// SMS 16 Sep 2008
             	int charCount;
             	if (fSourceViewer != null) {
+            		if (fSourceViewer.getDocument() == null) return; // LK: handle closed documents better
             		charCount = fSourceViewer.getDocument().getLength();
             	} else {
             		charCount = 0;
@@ -201,7 +211,7 @@
             	int lastLength = presentation.getLastStyleRange().length;
             	int end = lastStart + lastLength;
         		TextPresentation newPresentation = null;
-            	if (end >= charCount) {
+            	if (end > charCount) { // LK: > not >=
             		newPresentation = new TextPresentation();
             		Iterator presIt = presentation.getAllStyleRangeIterator();
             		while (presIt.hasNext()) {
Index: org.eclipse.imp.runtime/src/org/eclipse/imp/editor/UniversalEditor.java
===================================================================
--- org.eclipse.imp.runtime/src/org/eclipse/imp/editor/UniversalEditor.java	(revision 22255)
+++ org.eclipse.imp.runtime/src/org/eclipse/imp/editor/UniversalEditor.java	(working copy)
@@ -42,6 +42,7 @@
 import org.eclipse.imp.editor.internal.AnnotationCreator;
 import org.eclipse.imp.editor.internal.EditorErrorTickUpdater;
 import org.eclipse.imp.editor.internal.FoldingController;
+import org.eclipse.imp.editor.internal.PresentationController;
 import org.eclipse.imp.editor.internal.ProblemMarkerManager;
 import org.eclipse.imp.editor.internal.ToggleBreakpointsAdapter;
 import org.eclipse.imp.help.IMPHelp;
@@ -257,6 +258,24 @@
         setInsertMode(SMART_INSERT);
         fProblemMarkerManager= new ProblemMarkerManager();
     }
+    
+    public ServiceControllerManager getServiceControllerManager() { // LK
+        return fServiceControllerManager;
+    }
+    
+    public LanguageServiceManager getLanguageServiceManager() { // LK
+        return fLanguageServiceManager;
+    }
+    
+    public IPreferenceStore getThePreferenceStore() { // LK
+    	return super.getPreferenceStore();
+    }
+    
+    public void updateColoring(Region region) { // LK
+        PresentationController presentation = fServiceControllerManager.getPresentationController();
+		presentation.damage(region);
+        presentation.update(fLanguageServiceManager.getParseController(), new NullProgressMonitor());
+    }
 
     public Object getAdapter(Class required) {
         if (IContentOutlinePage.class.equals(required)) {
@@ -697,7 +716,8 @@
         IFile file= EditorInputUtils.getFile(editorInput);
         IPath filePath= EditorInputUtils.getPath(editorInput);
         try {
-            ISourceProject srcProject= (file != null) ? ModelFactory.open(file.getProject()) : null;
+        	// LK: check file.getProject() for null for out-of-workspace files
+            ISourceProject srcProject= (file != null && file.getProject() != null) ? ModelFactory.open(file.getProject()) : null;
 
             fLanguageServiceManager.getParseController().initialize(filePath, srcProject, fAnnotationCreator);
         } catch (ModelException e) {
@@ -1491,6 +1511,7 @@
             ContentAssistant ca= new ContentAssistant();
             ca.setContentAssistProcessor(fServiceControllerManager.getCompletionProcessor(), IDocument.DEFAULT_CONTENT_TYPE);
             ca.setInformationControlCreator(getInformationControlCreator(sourceViewer));
+            ca.enableColoredLabels(true); // LK
             return ca;
         }
 
@@ -1771,7 +1792,8 @@
                 if (fServiceControllerManager.getPresentationController() != null) {
 //                  System.out.println("Scheduling repair for damage to region " + damage.getOffset() + ":" + damage.getLength() + " in doc of length " + fDocument.getLength());
                     fServiceControllerManager.getPresentationController().damage(damage);
-                    if (hyperlinkRestore) {
+                    // LK: just always color for post-marker color correctness
+                    if (hyperlinkRestore || true) {
 //                      System.out.println("** Forcing repair for hyperlink damage to region " + damage.getOffset() + ":" + damage.getLength() + " in doc of length " + fDocument.getLength());
                         fServiceControllerManager.getPresentationController().update(fLanguageServiceManager.getParseController(), fProgressMonitor);
                     }
@@ -1845,6 +1867,7 @@
     }
 
     public IParseController getParseController() {
+    	if (fLanguageServiceManager == null) return null; // LK
         return fLanguageServiceManager.getParseController();
     }
     
Index: org.eclipse.imp.runtime/src/org/eclipse/imp/editor/SourceProposal.java
===================================================================
--- org.eclipse.imp.runtime/src/org/eclipse/imp/editor/SourceProposal.java	(revision 22255)
+++ org.eclipse.imp.runtime/src/org/eclipse/imp/editor/SourceProposal.java	(working copy)
@@ -134,7 +134,9 @@
 
     public void apply(IDocument document) {
         try {
-            document.replace(fRange.getOffset(), fRange.getLength(), fNewText.substring(fPrefix.length()));
+        	// LK: use accessors
+            Region range = getRange();
+			document.replace(range.getOffset(), range.getLength(), getNewText().substring(getPrefix().length()));
         } catch (BadLocationException e) {
             e.printStackTrace();
         }
@@ -155,6 +157,18 @@
     public Image getImage() {
         return null;
     }
+    
+    public String getNewText() { // LK
+		return fNewText;
+	}
+    
+    public Region getRange() { // LK
+		return fRange;
+	}
+    
+    public String getPrefix() { // LK
+		return fPrefix;
+	}
 
     public IContextInformation getContextInformation() {
         return null;
Index: org.eclipse.imp.runtime/src/org/eclipse/imp/utils/AnnotationUtils.java
===================================================================
--- org.eclipse.imp.runtime/src/org/eclipse/imp/utils/AnnotationUtils.java	(revision 22255)
+++ org.eclipse.imp.runtime/src/org/eclipse/imp/utils/AnnotationUtils.java	(working copy)
@@ -21,6 +21,7 @@
 import org.eclipse.jface.text.Position;
 import org.eclipse.jface.text.source.Annotation;
 import org.eclipse.jface.text.source.IAnnotationModel;
+import org.eclipse.jface.text.source.ILineDiffInfo;
 import org.eclipse.jface.text.source.ISourceViewer;
 import org.eclipse.jface.text.source.projection.AnnotationBag;
 
@@ -30,6 +31,7 @@
 
     public static String formatAnnotationList(List<Annotation> annotations) {
         if (annotations != null) {
+            removeLineDiffInfo(annotations); // LK
             if (annotations.size() == 1) {
                 // optimization
                 Annotation annotation= (Annotation) annotations.get(0);
@@ -52,6 +54,15 @@
         return null;
     }
 
+	private static void removeLineDiffInfo(List<Annotation> annotations) { // LK
+		if (annotations == null) return;
+		for (Iterator<Annotation> iter = annotations.iterator(); iter.hasNext(); ) {
+    		Annotation annotation = iter.next();
+    		if (annotation.getText() == null || annotation instanceof ILineDiffInfo)
+    			iter.remove();
+    	}
+	}
+	
     public static IAnnotationModel getAnnotationModel(ISourceViewer viewer) {
         // if (viewer instanceof ISourceViewerExtension2) {
         // ISourceViewerExtension2 extension= (ISourceViewerExtension2) viewer;
Index: org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceCache.java
===================================================================
--- org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceCache.java	(revision 22255)
+++ org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceCache.java	(working copy)
@@ -17,7 +17,7 @@
 public class PreferenceCache {
     public static boolean emitMessages= false;
 
-    public static int tabWidth= 8;
+    public static int tabWidth= 4; // LK: sane default tab width
 
     public static Font sourceFont;
 
Index: org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceInitializer.java
===================================================================
--- org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceInitializer.java	(revision 22255)
+++ org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceInitializer.java	(working copy)
@@ -42,7 +42,7 @@
         if (fontData != null && fontData.length > 0)
             PreferenceConverter.setDefault(store, PreferenceConstants.P_SOURCE_FONT, fontData);
 
-        store.setDefault(PreferenceConstants.P_TAB_WIDTH, 8);
+        store.setDefault(PreferenceConstants.P_TAB_WIDTH, 4); // LK: sane default tab width
         store.setDefault(PreferenceConstants.P_DUMP_TOKENS, false);
         store.setDefault(PreferenceConstants.EDITOR_MATCHING_BRACKETS, true);
 
Index: org.eclipse.imp.runtime/META-INF/MANIFEST.MF
===================================================================
--- org.eclipse.imp.runtime/META-INF/MANIFEST.MF	(revision 22255)
+++ org.eclipse.imp.runtime/META-INF/MANIFEST.MF	(working copy)
@@ -2,7 +2,7 @@
 Bundle-ManifestVersion: 2
 Bundle-Name: IMP Runtime (Incubation)
 Bundle-SymbolicName: org.eclipse.imp.runtime; singleton:=true
-Bundle-Version: 0.1.101
+Bundle-Version: 0.1.101.qualifier
 Bundle-Activator: org.eclipse.imp.runtime.RuntimePlugin
 Bundle-ActivationPolicy: lazy
 Eclipse-LazyStart: true
@@ -30,6 +30,7 @@
  org.eclipse.imp.builder,
  org.eclipse.imp.core,
  org.eclipse.imp.editor,
+ org.eclipse.imp.editor.internal,
  org.eclipse.imp.indexing,
  org.eclipse.imp.language,
  org.eclipse.imp.model,
