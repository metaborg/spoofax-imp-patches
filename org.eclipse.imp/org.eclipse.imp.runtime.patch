Index: org.eclipse.imp.runtime/src/org/eclipse/imp/language/LanguageRegistry.java
===================================================================
--- org.eclipse.imp.runtime/src/org/eclipse/imp/language/LanguageRegistry.java	(revision 22255)
+++ org.eclipse.imp.runtime/src/org/eclipse/imp/language/LanguageRegistry.java	(working copy)
@@ -21,6 +21,8 @@
 import java.util.List;
 import java.util.Map;
 
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.ResourcesPlugin;
 import org.eclipse.core.runtime.IConfigurationElement;
 import org.eclipse.core.runtime.IExtensionPoint;
 import org.eclipse.core.runtime.IPath;
@@ -134,7 +136,7 @@
 	public static Language findLanguage(IEditorInput editorInput, IDocumentProvider docProvider) {
 		if (!sIsFullyInitialized)
 			initializeRegistryAsNeeded();
-		IPath path= EditorInputUtils.getPath(editorInput);
+		IPath path= EditorInputUtils.getFile(editorInput).getLocation(); // LK
 
 		return findLanguage(path, docProvider.getDocument(editorInput));
 	}
@@ -164,7 +166,9 @@
 		            LanguageValidator validator = lang.getValidator();
 
 		            if (validator != null && docContents != null) {
-		                if (validator.validate(docContents)) {
+		            	// LK: needed for MetaFileLanguageValidator
+		            	IFile file = ResourcesPlugin.getWorkspace().getRoot().getFile(path);
+		            	if (validator.validate(file) ||validator.validate(docContents)) {
 		                    return lang;
 		                }
 		            } else {
@@ -383,7 +387,9 @@
         for (String ext : extensions) {
 	        IFileEditorMapping mapping= findMappingFor(ext, mappings);
 
-	        if (mapping == null || mapping.getDefaultEditor().getId().equals(sUniversalEditor.getId())) {
+	        if (mapping == null
+	        		|| (!(mapping instanceof IMPFileEditorMapping) // LK: mapping may already be a IMPFileEditorMapping 
+	        		     && mapping.getDefaultEditor().getId().equals(sUniversalEditor.getId()))) {
 	            // Replace the file editor mapping even if it already pointed to the universal editor,
 	            // since the persisted association turns into a FileEditorMapping when re-read, thus
 	            // losing the icon (which FileEditorMapping gets from the IEditorDescriptor).
Index: org.eclipse.imp.runtime/src/org/eclipse/imp/editor/ServiceControllerManager.java
===================================================================
--- org.eclipse.imp.runtime/src/org/eclipse/imp/editor/ServiceControllerManager.java	(revision 22255)
+++ org.eclipse.imp.runtime/src/org/eclipse/imp/editor/ServiceControllerManager.java	(working copy)
@@ -48,6 +48,11 @@
         if (fLanguageServiceManager.getHyperLinkDetector() != null)
             fHyperLinkController= new SourceHyperlinkController(fLanguageServiceManager.getHyperLinkDetector(), fTextEditor);
     }
+    
+    public ServiceControllerManager() { // LK: TODO: REMOVE ME
+    	fTextEditor = null;
+    
+    }
 
     public void initialize() {
         IRegionSelectionService regionSelector= (IRegionSelectionService) fTextEditor.getAdapter(IRegionSelectionService.class);
Index: org.eclipse.imp.runtime/src/org/eclipse/imp/editor/ParserScheduler.java
===================================================================
--- org.eclipse.imp.runtime/src/org/eclipse/imp/editor/ParserScheduler.java	(revision 22255)
+++ org.eclipse.imp.runtime/src/org/eclipse/imp/editor/ParserScheduler.java	(working copy)
@@ -29,6 +29,7 @@
 import org.eclipse.jface.text.IDocument;
 import org.eclipse.ui.IEditorInput;
 import org.eclipse.ui.IEditorPart;
+import org.eclipse.ui.texteditor.AbstractTextEditor;
 import org.eclipse.ui.texteditor.IDocumentProvider;
 
 /**
@@ -64,7 +65,7 @@
     }
 
     public IStatus run(IProgressMonitor monitor) {
-        if (fParseController == null || fDocumentProvider == null) {
+        if (fParseController == null || ((AbstractTextEditor) fEditorPart).getDocumentProvider() == null) { // LK: test if document provider is null to find out if editor was closed
             /* Editor was closed, or no parse controller */
             return Status.OK_STATUS;
         }
@@ -82,8 +83,9 @@
             // Just make sure the document contents gets parsed once (and only once).
             fMsgHandler.clearMessages();
             fParseController.parse(document.get(), monitor);
-            if (!monitor.isCanceled())
+            if (!monitor.isCanceled()) {
                 notifyModelListeners(monitor);
+            }
         } catch (Exception e) {
             ErrorHandler.reportError("Error running parser for language " + fParseController.getLanguage().getName() + " and input " + editorInput.getName() + ":", e);
             // RMF 8/2/2006 - Notify the AST listeners even on an exception - the compiler front end
Index: org.eclipse.imp.runtime/src/org/eclipse/imp/editor/internal/PresentationController.java
===================================================================
--- org.eclipse.imp.runtime/src/org/eclipse/imp/editor/internal/PresentationController.java	(revision 22255)
+++ org.eclipse.imp.runtime/src/org/eclipse/imp/editor/internal/PresentationController.java	(working copy)
@@ -109,6 +109,9 @@
         IRegion bigRegion= fColorer.calculateDamageExtent(region, fParseCtlr);
 
         if (bigRegion != null) {
+        	// LK: (no changes, just a comment)
+        	// No synchronized statement here avoids a deadlock in the colorer implementation,
+        	// which might need main thread access to create new SWT Color Objects 
             fWorkItems.push(bigRegion);
         }
     }
@@ -157,7 +160,7 @@
             int offset= locator.getStartOffset(token);
             int end= locator.getEndOffset(token);
 
-            if (offset <= prevEnd && end >= prevOffset) {
+            if (offset <= prevEnd /*&& end >= prevOffset*/) { // LK: Avoid illegal styleRange
                 continue;
             }
             changeTokenPresentation(parseController, presentation, token, locator);
Index: org.eclipse.imp.runtime/src/org/eclipse/imp/editor/UniversalEditor.java
===================================================================
--- org.eclipse.imp.runtime/src/org/eclipse/imp/editor/UniversalEditor.java	(revision 22255)
+++ org.eclipse.imp.runtime/src/org/eclipse/imp/editor/UniversalEditor.java	(working copy)
@@ -42,6 +42,7 @@
 import org.eclipse.imp.editor.internal.AnnotationCreator;
 import org.eclipse.imp.editor.internal.EditorErrorTickUpdater;
 import org.eclipse.imp.editor.internal.FoldingController;
+import org.eclipse.imp.editor.internal.PresentationController;
 import org.eclipse.imp.editor.internal.ProblemMarkerManager;
 import org.eclipse.imp.editor.internal.ToggleBreakpointsAdapter;
 import org.eclipse.imp.help.IMPHelp;
@@ -257,6 +258,16 @@
         setInsertMode(SMART_INSERT);
         fProblemMarkerManager= new ProblemMarkerManager();
     }
+    
+    public ServiceControllerManager getServiceControllerManager() { // LK
+        return fServiceControllerManager;
+    }
+    
+    public void updateColoring(Region region) { // LK
+        PresentationController presentation = fServiceControllerManager.getPresentationController();
+		presentation.damage(region);
+        presentation.update(fLanguageServiceManager.getParseController(), new NullProgressMonitor());
+    }
 
     public Object getAdapter(Class required) {
         if (IContentOutlinePage.class.equals(required)) {
@@ -1771,7 +1782,8 @@
                 if (fServiceControllerManager.getPresentationController() != null) {
 //                  System.out.println("Scheduling repair for damage to region " + damage.getOffset() + ":" + damage.getLength() + " in doc of length " + fDocument.getLength());
                     fServiceControllerManager.getPresentationController().damage(damage);
-                    if (hyperlinkRestore) {
+                    // LK: just always color for post-marker color correctness
+                    if (hyperlinkRestore || true) {
 //                      System.out.println("** Forcing repair for hyperlink damage to region " + damage.getOffset() + ":" + damage.getLength() + " in doc of length " + fDocument.getLength());
                         fServiceControllerManager.getPresentationController().update(fLanguageServiceManager.getParseController(), fProgressMonitor);
                     }
@@ -1845,6 +1857,7 @@
     }
 
     public IParseController getParseController() {
+    	if (fLanguageServiceManager == null) return null; // LK
         return fLanguageServiceManager.getParseController();
     }
     
Index: org.eclipse.imp.runtime/src/org/eclipse/imp/utils/AnnotationUtils.java
===================================================================
--- org.eclipse.imp.runtime/src/org/eclipse/imp/utils/AnnotationUtils.java	(revision 22255)
+++ org.eclipse.imp.runtime/src/org/eclipse/imp/utils/AnnotationUtils.java	(working copy)
@@ -21,6 +21,7 @@
 import org.eclipse.jface.text.Position;
 import org.eclipse.jface.text.source.Annotation;
 import org.eclipse.jface.text.source.IAnnotationModel;
+import org.eclipse.jface.text.source.ILineDiffInfo;
 import org.eclipse.jface.text.source.ISourceViewer;
 import org.eclipse.jface.text.source.projection.AnnotationBag;
 
@@ -30,6 +31,7 @@
 
     public static String formatAnnotationList(List<Annotation> annotations) {
         if (annotations != null) {
+            removeLineDiffInfo(annotations); // LK
             if (annotations.size() == 1) {
                 // optimization
                 Annotation annotation= (Annotation) annotations.get(0);
@@ -52,6 +54,15 @@
         return null;
     }
 
+	private static void removeLineDiffInfo(List<Annotation> annotations) { // LK
+		if (annotations == null) return;
+		for (Iterator<Annotation> iter = annotations.iterator(); iter.hasNext(); ) {
+    		Annotation annotation = iter.next();
+    		if (annotation instanceof ILineDiffInfo)
+    			iter.remove();
+    	}
+	}
+	
     public static IAnnotationModel getAnnotationModel(ISourceViewer viewer) {
         // if (viewer instanceof ISourceViewerExtension2) {
         // ISourceViewerExtension2 extension= (ISourceViewerExtension2) viewer;
Index: org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceCache.java
===================================================================
--- org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceCache.java	(revision 22255)
+++ org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceCache.java	(working copy)
@@ -17,7 +17,7 @@
 public class PreferenceCache {
     public static boolean emitMessages= false;
 
-    public static int tabWidth= 8;
+    public static int tabWidth= 4; // LK: sane default tab width
 
     public static Font sourceFont;
 
Index: org.eclipse.imp.runtime/META-INF/MANIFEST.MF
===================================================================
--- org.eclipse.imp.runtime/META-INF/MANIFEST.MF	(revision 22255)
+++ org.eclipse.imp.runtime/META-INF/MANIFEST.MF	(working copy)
@@ -2,7 +2,7 @@
 Bundle-ManifestVersion: 2
 Bundle-Name: IMP Runtime (Incubation)
 Bundle-SymbolicName: org.eclipse.imp.runtime; singleton:=true
-Bundle-Version: 0.1.101
+Bundle-Version: 0.1.101.qualifier
 Bundle-Activator: org.eclipse.imp.runtime.RuntimePlugin
 Bundle-ActivationPolicy: lazy
 Eclipse-LazyStart: true
@@ -30,6 +30,7 @@
  org.eclipse.imp.builder,
  org.eclipse.imp.core,
  org.eclipse.imp.editor,
+ org.eclipse.imp.editor.internal,
  org.eclipse.imp.indexing,
  org.eclipse.imp.language,
  org.eclipse.imp.model,
